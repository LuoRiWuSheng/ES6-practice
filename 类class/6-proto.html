<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
        class A {
            constructor() {
                this.name = "父类的name"
            }

            say() {
                console.log("2")
            }
        }
       
        class B extends A {
            constructor() {
                super()
                this.name2 = '子类的name2'
            }
        }
        let a = new A()

        let b = new B()
        
        console.log(A)


        console.log(a.__proto__ === A.prototype, '实例对象的__proto__ 指向原型对象')

        console.log('子类b的**实例对象**拥有的内容是-->',b)  // 有2个属性， constructor， __proto__
        console.log("子类B的实例对象的内部属性__proto__的__proto__是指向父类的原型对象",b.__proto__.__proto__ === A.prototype)
        console.log('子类B类的内部属性__proto__指向父类的构造函数', B.__proto__ === A, '构造函数的继承')
        console.log(B.prototype.__proto__ === A.prototype, '对父类原型方法的继承') // true


        /**
         * 1、子类的原型对象的内部属性__proto__ 指向父类的原型对象
         * 2、子类实例b的的内部属性__proto__的 __proto__指向父类A的原型对象
        */

    </script>
</head>
<body>
    
</body>
</html>